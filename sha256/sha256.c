#include <stdio.h>
#include <sys/types.h>

#include "sha256.h"

#define BLOCK_SIZE 64
#define SCHEDULE_SIZE 64

#ifdef DEBUG
void print_block(const u_int8_t block[BLOCK_SIZE]) {
    for (u_int8_t i = 0; i < BLOCK_SIZE; i += 4) {
        printf("%02x-%02x: %08b %08b %08b %08b\n", i, i + 3, block[i], block[i + 1], block[i + 2],
               block[i + 3]);
    }
}
#endif

#ifdef DEBUG
void print_32_int_array(u_int8_t size, const u_int32_t arr[size]) {
    for (u_int8_t i = 0; i < size; i++) {
        printf("%3d: %032b\n", i, arr[i]);
    }
}
#endif

u_int32_t ror(u_int32_t x, u_int32_t n) {
    return (x >> n) | (x << (32 - n));
}

// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311
const u_int32_t k[64] = {
    0b01000010100010100010111110011000, 0b01110001001101110100010010010001,
    0b10110101110000001111101111001111, 0b11101001101101011101101110100101,
    0b00111001010101101100001001011011, 0b01011001111100010001000111110001,
    0b10010010001111111000001010100100, 0b10101011000111000101111011010101,
    0b11011000000001111010101010011000, 0b00010010100000110101101100000001,
    0b00100100001100011000010110111110, 0b01010101000011000111110111000011,
    0b01110010101111100101110101110100, 0b10000000110111101011000111111110,
    0b10011011110111000000011010100111, 0b11000001100110111111000101110100,
    0b11100100100110110110100111000001, 0b11101111101111100100011110000110,
    0b00001111110000011001110111000110, 0b00100100000011001010000111001100,
    0b00101101111010010010110001101111, 0b01001010011101001000010010101010,
    0b01011100101100001010100111011100, 0b01110110111110011000100011011010,
    0b10011000001111100101000101010010, 0b10101000001100011100011001101101,
    0b10110000000000110010011111001000, 0b10111111010110010111111111000111,
    0b11000110111000000000101111110011, 0b11010101101001111001000101000111,
    0b00000110110010100110001101010001, 0b00010100001010010010100101100111,
    0b00100111101101110000101010000101, 0b00101110000110110010000100111000,
    0b01001101001011000110110111111100, 0b01010011001110000000110100010011,
    0b01100101000010100111001101010100, 0b01110110011010100000101010111011,
    0b10000001110000101100100100101110, 0b10010010011100100010110010000101,
    0b10100010101111111110100010100001, 0b10101000000110100110011001001011,
    0b11000010010010111000101101110000, 0b11000111011011000101000110100011,
    0b11010001100100101110100000011001, 0b11010110100110010000011000100100,
    0b11110100000011100011010110000101, 0b00010000011010101010000001110000,
    0b00011001101001001100000100010110, 0b00011110001101110110110000001000,
    0b00100111010010000111011101001100, 0b00110100101100001011110010110101,
    0b00111001000111000000110010110011, 0b01001110110110001010101001001010,
    0b01011011100111001100101001001111, 0b01101000001011100110111111110011,
    0b01110100100011111000001011101110, 0b01111000101001010110001101101111,
    0b10000100110010000111100000010100, 0b10001100110001110000001000001000,
    0b10010000101111101111111111111010, 0b10100100010100000110110011101011,
    0b10111110111110011010001111110111, 0b11000110011100010111100011110010,
};

void sha256_hash() {
    const int NB_BLOCKS = 1;
    u_int8_t blocks[NB_BLOCKS][BLOCK_SIZE];
    for (u_int8_t i = 0; i < NB_BLOCKS; i++) {
        for (u_int8_t j = 0; j < BLOCK_SIZE; j++) {
            blocks[i][j] = 0;
        }
    }

    blocks[0][0] = 0x66;
    blocks[0][1] = 0x6f;
    blocks[0][2] = 0x6f;

    blocks[0][3] = 0x80;

    blocks[0][63] = 24;

    // first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19
    u_int32_t h0 = 0b01101010000010011110011001100111;
    u_int32_t h1 = 0b10111011011001111010111010000101;
    u_int32_t h2 = 0b00111100011011101111001101110010;
    u_int32_t h3 = 0b10100101010011111111010100111010;
    u_int32_t h4 = 0b01010001000011100101001001111111;
    u_int32_t h5 = 0b10011011000001010110100010001100;
    u_int32_t h6 = 0b00011111100000111101100110101011;
    u_int32_t h7 = 0b01011011111000001100110100011001;

    u_int32_t w[SCHEDULE_SIZE] = {0};

    for (int i = 0; i < NB_BLOCKS; i++) {
        for (u_int8_t j = 0; j < 16; j++) {
            w[j] = blocks[i][4 * j] << 24 | blocks[i][4 * j + 1] << 16 | blocks[i][4 * j + 2] << 8 |
                   blocks[i][4 * j + 3] << 0;
        }

        for (u_int8_t j = 16; j < SCHEDULE_SIZE; j++) {
            u_int8_t i0 = j - 15;
            u_int8_t i1 = j - 2;
            u_int32_t s0 = ror(w[i0], 7) ^ ror(w[i0], 18) ^ (w[i0] >> 3);
            u_int32_t s1 = ror(w[i1], 17) ^ ror(w[i1], 19) ^ (w[i1] >> 10);
            w[j] = w[j - 16] + s0 + w[j - 7] + s1;
        }

        u_int32_t a = h0, b = h1, c = h2, d = h3, e = h4, f = h5, g = h6, h = h7;

        for (int j = 1; j < 65; j++) {
            u_int32_t s1 = ror(e, 6) ^ ror(e, 11) ^ ror(e, 25);
            u_int32_t choice = (e & f) ^ (~e & g);
            u_int32_t s0 = ror(a, 2) ^ ror(a, 13) ^ ror(a, 22);
            u_int32_t majority = (a & b) ^ (a & c) ^ (b & c);

            u_int32_t tmp_1 = h + s1 + choice + k[j - 1] + w[j - 1];
            u_int32_t tmp_2 = s0 + majority;

            h = g;
            g = f;
            f = e;
            e = d + tmp_1;
            d = c;
            c = b;
            b = a;
            a = tmp_1 + tmp_2;
        }

        h0 = h0 + a;
        h1 = h1 + b;
        h2 = h2 + c;
        h3 = h3 + d;
        h4 = h4 + e;
        h5 = h5 + f;
        h6 = h6 + g;
        h7 = h7 + h;
    }

    printf("%08x%08x%08x%08x%08x%08x%08x%08x\n", h0, h1, h2, h3, h4, h5, h6, h7);
}
